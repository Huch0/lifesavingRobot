###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       19/Dec/2024  22:31:36
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\motor.c
#    Command line =  
#        -f C:\Users\pnu2\AppData\Local\Temp\EW872C.tmp
#        (C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\motor.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Debug\List
#        -o
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\
#        -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\inc\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Debug\List\motor.lst
#    Object file  =  
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Debug\Obj\motor.o
#
###############################################################################

C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\motor.c
      1          #include "motor.h"
      2          
      3          extern int flag_front_obstacle;
      4          extern int flag_left_obstacle;
      5          extern int flag_right_obstacle;
      6          extern int flag_back_obstacle;
      7          

   \                                 In section .bss, align 4
      8          int motor_mode;
   \                     motor_mode:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
      9          unsigned int motor_delay = 1000000;
   \                     motor_delay:
   \   00000000   0x000F4240         DC32 1000000
     10          
     11          

   \                                 In section .text, align 2, keep-with-next
     12          void motor_rcc_configure(void)
     13          {
   \                     motor_rcc_configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     14              RCC_APB2PeriphClockCmd(MOTOR_FL1_RCC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     15              RCC_APB2PeriphClockCmd(MOTOR_FL2_RCC, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     16              RCC_APB2PeriphClockCmd(MOTOR_FR1_RCC, ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     17              RCC_APB2PeriphClockCmd(MOTOR_FR2_RCC, ENABLE);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     18              RCC_APB2PeriphClockCmd(MOTOR_BL1_RCC, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     19              RCC_APB2PeriphClockCmd(MOTOR_BL2_RCC, ENABLE);
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x2020             MOVS     R0,#+32
   \   0000002E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     20              RCC_APB2PeriphClockCmd(MOTOR_BR1_RCC, ENABLE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     21              RCC_APB2PeriphClockCmd(MOTOR_BR2_RCC, ENABLE);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x2020             MOVS     R0,#+32
   \   0000003E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     22          }
   \   00000042   0xBD01             POP      {R0,PC}          ;; return
     23          

   \                                 In section .text, align 2, keep-with-next
     24          void motor_gpio_configure(void)
     25          {
   \                     motor_gpio_configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     26              GPIO_InitTypeDef GPIO_InitStructure;
     27              GPIO_InitStructure.GPIO_Pin = MOTOR_FL1_PIN;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     28              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     29              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0xF88D 0x0003      STRB     R0,[SP, #+3]
     30              GPIO_Init(MOTOR_FL1_PORT, &GPIO_InitStructure);
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   0000001A   0x.... 0x....      BL       GPIO_Init
     31          
     32              GPIO_InitStructure.GPIO_Pin = MOTOR_FL2_PIN;
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     33              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xF88D 0x0002      STRB     R0,[SP, #+2]
     34              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000002A   0x2010             MOVS     R0,#+16
   \   0000002C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     35              GPIO_Init(MOTOR_FL2_PORT, &GPIO_InitStructure);
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   00000036   0x.... 0x....      BL       GPIO_Init
     36          
     37              GPIO_InitStructure.GPIO_Pin = MOTOR_FR1_PIN;
   \   0000003A   0x2010             MOVS     R0,#+16
   \   0000003C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     38              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0xF88D 0x0002      STRB     R0,[SP, #+2]
     39              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000046   0x2010             MOVS     R0,#+16
   \   00000048   0xF88D 0x0003      STRB     R0,[SP, #+3]
     40              GPIO_Init(MOTOR_FR1_PORT, &GPIO_InitStructure);
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   00000052   0x.... 0x....      BL       GPIO_Init
     41          
     42              GPIO_InitStructure.GPIO_Pin = MOTOR_FR2_PIN;
   \   00000056   0x2080             MOVS     R0,#+128
   \   00000058   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     43              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0xF88D 0x0002      STRB     R0,[SP, #+2]
     44              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000062   0x2010             MOVS     R0,#+16
   \   00000064   0xF88D 0x0003      STRB     R0,[SP, #+3]
     45              GPIO_Init(MOTOR_FR2_PORT, &GPIO_InitStructure);
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   0000006E   0x.... 0x....      BL       GPIO_Init
     46          
     47              GPIO_InitStructure.GPIO_Pin = MOTOR_BL1_PIN;
   \   00000072   0xF44F 0x7000      MOV      R0,#+512
   \   00000076   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     48              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000007A   0x2003             MOVS     R0,#+3
   \   0000007C   0xF88D 0x0002      STRB     R0,[SP, #+2]
     49              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000080   0x2010             MOVS     R0,#+16
   \   00000082   0xF88D 0x0003      STRB     R0,[SP, #+3]
     50              GPIO_Init(MOTOR_BL1_PORT, &GPIO_InitStructure);
   \   00000086   0x4669             MOV      R1,SP
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   0000008C   0x.... 0x....      BL       GPIO_Init
     51          
     52              GPIO_InitStructure.GPIO_Pin = MOTOR_BL2_PIN;
   \   00000090   0xF44F 0x7080      MOV      R0,#+256
   \   00000094   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     53              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000098   0x2003             MOVS     R0,#+3
   \   0000009A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     54              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000009E   0x2010             MOVS     R0,#+16
   \   000000A0   0xF88D 0x0003      STRB     R0,[SP, #+3]
     55              GPIO_Init(MOTOR_BL2_PORT, &GPIO_InitStructure);
   \   000000A4   0x4669             MOV      R1,SP
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   000000AA   0x.... 0x....      BL       GPIO_Init
     56          
     57              GPIO_InitStructure.GPIO_Pin = MOTOR_BR1_PIN;
   \   000000AE   0xF44F 0x4000      MOV      R0,#+32768
   \   000000B2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     58              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000B6   0x2003             MOVS     R0,#+3
   \   000000B8   0xF88D 0x0002      STRB     R0,[SP, #+2]
     59              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   000000BC   0x2010             MOVS     R0,#+16
   \   000000BE   0xF88D 0x0003      STRB     R0,[SP, #+3]
     60              GPIO_Init(MOTOR_BR1_PORT, &GPIO_InitStructure);
   \   000000C2   0x4669             MOV      R1,SP
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   000000C8   0x.... 0x....      BL       GPIO_Init
     61          
     62              GPIO_InitStructure.GPIO_Pin = MOTOR_BR2_PIN;
   \   000000CC   0xF44F 0x4080      MOV      R0,#+16384
   \   000000D0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     63              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000D4   0x2003             MOVS     R0,#+3
   \   000000D6   0xF88D 0x0002      STRB     R0,[SP, #+2]
     64              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   000000DA   0x2010             MOVS     R0,#+16
   \   000000DC   0xF88D 0x0003      STRB     R0,[SP, #+3]
     65              GPIO_Init(MOTOR_BR2_PORT, &GPIO_InitStructure);
   \   000000E0   0x4669             MOV      R1,SP
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   000000E6   0x.... 0x....      BL       GPIO_Init
     66          }
   \   000000EA   0xBD01             POP      {R0,PC}          ;; return
     67          

   \                                 In section .text, align 2, keep-with-next
     68          void motor_init(void)
     69          {
   \                     motor_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     70              motor_rcc_configure();
   \   00000002   0x.... 0x....      BL       motor_rcc_configure
     71              motor_gpio_configure();
   \   00000006   0x.... 0x....      BL       motor_gpio_configure
     72              motor_mode = MOTOR_MANUAL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   00000010   0x6008             STR      R0,[R1, #+0]
     73              stop();
   \   00000012   0x.... 0x....      BL       stop
     74          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
     75          
     76          
     77          

   \                                 In section .text, align 2, keep-with-next
     78          void manual_control(void)
     79          {
   \                     manual_control: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     80              uint16_t user_input = bt_get_user_input();
   \   00000002   0x.... 0x....      BL       bt_get_user_input
   \   00000006   0x0004             MOVS     R4,R0
     81              
     82              printf("%d\n", user_input);
                     ^
Warning[Pe223]: function "printf" declared implicitly
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x....             ADR.N    R0,??DataTable8  ;; "%d\n"
   \   0000000E   0x.... 0x....      BL       printf
     83              switch (user_input)
   \   00000012   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000014   0x2C61             CMP      R4,#+97
   \   00000016   0xD019             BEQ.N    ??manual_control_0
   \   00000018   0x2C63             CMP      R4,#+99
   \   0000001A   0xD029             BEQ.N    ??manual_control_1
   \   0000001C   0x2C64             CMP      R4,#+100
   \   0000001E   0xD01B             BEQ.N    ??manual_control_2
   \   00000020   0x2C73             CMP      R4,#+115
   \   00000022   0xD00D             BEQ.N    ??manual_control_3
   \   00000024   0x2C77             CMP      R4,#+119
   \   00000026   0xD002             BEQ.N    ??manual_control_4
   \   00000028   0x2C78             CMP      R4,#+120
   \   0000002A   0xD01B             BEQ.N    ??manual_control_5
   \   0000002C   0xE027             B.N      ??manual_control_6
     84              {
     85              case 119: //w
     86                printf("go forward\n");
   \                     ??manual_control_4: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable10_2
   \   00000030   0x.... 0x....      BL       printf
     87                  go_forward();
   \   00000034   0x.... 0x....      BL       go_forward
     88                  bt_send_to_user("go forward\n");
   \   00000038   0x....             LDR.N    R0,??DataTable10_2
   \   0000003A   0x.... 0x....      BL       bt_send_to_user
     89                  break;
   \   0000003E   0xE01E             B.N      ??manual_control_7
     90              case 115: //s
     91                  go_backward();
   \                     ??manual_control_3: (+1)
   \   00000040   0x.... 0x....      BL       go_backward
     92                  bt_send_to_user("go backward\n");
   \   00000044   0x....             LDR.N    R0,??DataTable10_3
   \   00000046   0x.... 0x....      BL       bt_send_to_user
     93                  break;
   \   0000004A   0xE018             B.N      ??manual_control_7
     94              case 97: //a
     95                  turn_left();
   \                     ??manual_control_0: (+1)
   \   0000004C   0x.... 0x....      BL       turn_left
     96                  bt_send_to_user("turn left\n");
   \   00000050   0x....             LDR.N    R0,??DataTable10_4
   \   00000052   0x.... 0x....      BL       bt_send_to_user
     97                  break;
   \   00000056   0xE012             B.N      ??manual_control_7
     98              case 100: //d
     99                  turn_right();
   \                     ??manual_control_2: (+1)
   \   00000058   0x.... 0x....      BL       turn_right
    100                  bt_send_to_user("turn right\n");
   \   0000005C   0x....             LDR.N    R0,??DataTable10_5
   \   0000005E   0x.... 0x....      BL       bt_send_to_user
    101                  break;
   \   00000062   0xE00C             B.N      ??manual_control_7
    102              case 120: //x
    103                  stop();
   \                     ??manual_control_5: (+1)
   \   00000064   0x.... 0x....      BL       stop
    104                  bt_send_to_user("stop\n");
   \   00000068   0x....             LDR.N    R0,??DataTable10_6
   \   0000006A   0x.... 0x....      BL       bt_send_to_user
    105                  break;
   \   0000006E   0xE006             B.N      ??manual_control_7
    106              case 99: //c
    107                  motor_mode = MOTOR_AUTO;
   \                     ??manual_control_1: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x....             LDR.N    R1,??DataTable10_1
   \   00000074   0x6008             STR      R0,[R1, #+0]
    108                  bt_send_to_user("Auto mode activated\n");
   \   00000076   0x....             LDR.N    R0,??DataTable10_7
   \   00000078   0x.... 0x....      BL       bt_send_to_user
    109                  break;
   \   0000007C   0xE7FF             B.N      ??manual_control_7
    110              default:
    111                  break;
    112              }
    113          }
   \                     ??manual_control_6: (+1)
   \                     ??manual_control_7: (+1)
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
    114          

   \                                 In section .bss, align 4
    115          int auto_counter = 0;
   \                     auto_counter:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    116          void auto_control()
    117          {
   \                     auto_control: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    118              uint16_t user = bt_get_user_input();
   \   00000002   0x.... 0x....      BL       bt_get_user_input
   \   00000006   0x0004             MOVS     R4,R0
    119              //delay_us(10000);
    120              //USART_SendData(USART1, 97);
    121              //delay_us(10);
    122              printf("%d\n", user);
                     ^
Warning[Pe223]: function "printf" declared implicitly
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x....             ADR.N    R0,??DataTable8  ;; "%d\n"
   \   0000000E   0x.... 0x....      BL       printf
    123              if (user == 99) {
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x2863             CMP      R0,#+99
   \   00000018   0xD109             BNE.N    ??auto_control_0
    124                  auto_counter = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable10_8
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    125                  motor_mode = MOTOR_MANUAL;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable10_1
   \   00000024   0x6008             STR      R0,[R1, #+0]
    126                  bt_send_to_user("Manual mode activated\n");
   \   00000026   0x....             LDR.N    R0,??DataTable10_9
   \   00000028   0x.... 0x....      BL       bt_send_to_user
    127                  return;
   \   0000002C   0xE045             B.N      ??auto_control_1
    128              }
    129                
    130              if (user != 122)
   \                     ??auto_control_0: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x287A             CMP      R0,#+122
   \   00000034   0xD012             BEQ.N    ??auto_control_2
    131              {   
    132                  auto_counter ++;
   \   00000036   0x....             LDR.N    R0,??DataTable10_8
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x....             LDR.N    R1,??DataTable10_8
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    133                  if (auto_counter == 1) return;
   \   00000040   0x....             LDR.N    R0,??DataTable10_8
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD038             BEQ.N    ??auto_control_1
    134                  auto_counter = 0;
   \                     ??auto_control_3: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x....             LDR.N    R1,??DataTable10_8
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    135                  motor_mode = MOTOR_MANUAL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x....             LDR.N    R1,??DataTable10_1
   \   00000052   0x6008             STR      R0,[R1, #+0]
    136                  bt_send_to_user("Manual mode activated\n");
   \   00000054   0x....             LDR.N    R0,??DataTable10_9
   \   00000056   0x.... 0x....      BL       bt_send_to_user
    137                  return;
   \   0000005A   0xE02E             B.N      ??auto_control_1
    138              }
    139              else if (!flag_front_obstacle)
   \                     ??auto_control_2: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable10_10
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD105             BNE.N    ??auto_control_4
    140              {
    141                  go_forward();
   \   00000064   0x.... 0x....      BL       go_forward
    142                  bt_send_to_user("go forward\n");
   \   00000068   0x....             LDR.N    R0,??DataTable10_2
   \   0000006A   0x.... 0x....      BL       bt_send_to_user
   \   0000006E   0xE018             B.N      ??auto_control_5
    143              }
    144              else if (!flag_left_obstacle)
   \                     ??auto_control_4: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable10_11
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD105             BNE.N    ??auto_control_6
    145              {
    146                  turn_left();
   \   00000078   0x.... 0x....      BL       turn_left
    147                  bt_send_to_user("turn left\n");
   \   0000007C   0x....             LDR.N    R0,??DataTable10_4
   \   0000007E   0x.... 0x....      BL       bt_send_to_user
   \   00000082   0xE00E             B.N      ??auto_control_5
    148              }
    149              else if (!flag_right_obstacle)
   \                     ??auto_control_6: (+1)
   \   00000084   0x....             LDR.N    R0,??DataTable10_12
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD105             BNE.N    ??auto_control_7
    150              {
    151                  turn_right();
   \   0000008C   0x.... 0x....      BL       turn_right
    152                  bt_send_to_user("turn right\n");
   \   00000090   0x....             LDR.N    R0,??DataTable10_5
   \   00000092   0x.... 0x....      BL       bt_send_to_user
   \   00000096   0xE004             B.N      ??auto_control_5
    153              }
    154              /*
    155              else if (!flag_back_obstacle)
    156              {
    157                  turn_left();
    158                  bt_send_to_user("turn left\n");
    159                  turn_left();
    160                  bt_send_to_user("turn left\n");
    161                  //go_backward();
    162                  //bt_send_to_user("go backward\n");
    163              }
    164          */
    165              else
    166              {
    167                  go_backward();
   \                     ??auto_control_7: (+1)
   \   00000098   0x.... 0x....      BL       go_backward
    168                  bt_send_to_user("go backward\n");
   \   0000009C   0x....             LDR.N    R0,??DataTable10_3
   \   0000009E   0x.... 0x....      BL       bt_send_to_user
    169                  //stop();
    170                  //bt_send_to_user("stop\n");
    171              }
    172              delay_us(1000000); //1s
   \                     ??auto_control_5: (+1)
   \   000000A2   0x....             LDR.N    R0,??DataTable10_13  ;; 0xf4240
   \   000000A4   0x.... 0x....      BL       delay_us
    173              USART_SendData(USART1, user);
   \   000000A8   0x0021             MOVS     R1,R4
   \   000000AA   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000AC   0x....             LDR.N    R0,??DataTable10_14  ;; 0x40013800
   \   000000AE   0x.... 0x....      BL       USART_SendData
    174              bt_send_to_user((char*)user);
   \   000000B2   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       bt_send_to_user
    175          }
   \                     ??auto_control_1: (+1)
   \   000000BA   0xBD10             POP      {R4,PC}          ;; return
    176          

   \                                 In section .text, align 2, keep-with-next
    177          void motor_control()
    178          {
   \                     motor_control: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    179              if (motor_mode == MOTOR_MANUAL)
   \   00000002   0x....             LDR.N    R0,??DataTable10_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD102             BNE.N    ??motor_control_0
    180              {
    181                  manual_control();
   \   0000000A   0x.... 0x....      BL       manual_control
   \   0000000E   0xE005             B.N      ??motor_control_1
    182              }
    183              else if (motor_mode == MOTOR_AUTO)
   \                     ??motor_control_0: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable10_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD101             BNE.N    ??motor_control_1
    184              {
    185                  auto_control();
   \   00000018   0x.... 0x....      BL       auto_control
    186              }
    187          }
   \                     ??motor_control_1: (+1)
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    188          

   \                                 In section .text, align 2, keep-with-next
    189          void go_forward(void)
    190          {
   \                     go_forward: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    191              GPIO_SetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_SetBits
    192              GPIO_ResetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_ResetBits
    193          
    194              GPIO_SetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_SetBits
    195              GPIO_ResetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_ResetBits
    196          
    197              GPIO_SetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7100      MOV      R1,#+512
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_SetBits
    198              GPIO_ResetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7180      MOV      R1,#+256
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    199          
    200              GPIO_SetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4100      MOV      R1,#+32768
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_SetBits
    201              GPIO_ResetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4180      MOV      R1,#+16384
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    202          
    203              delay_us(100000); // 0.1s
   \   0000004A   0x....             LDR.N    R0,??DataTable10_15  ;; 0x186a0
   \   0000004C   0x.... 0x....      BL       delay_us
    204              stop();
   \   00000050   0x.... 0x....      BL       stop
    205          }
   \   00000054   0xBD01             POP      {R0,PC}          ;; return
    206          

   \                                 In section .text, align 2, keep-with-next
    207          void go_backward(void)
    208          {
   \                     go_backward: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    209              GPIO_ResetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_ResetBits
    210              GPIO_SetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_SetBits
    211          
    212              GPIO_ResetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_ResetBits
    213              GPIO_SetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_SetBits
    214          
    215              GPIO_ResetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7100      MOV      R1,#+512
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_ResetBits
    216              GPIO_SetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7180      MOV      R1,#+256
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_SetBits
    217          
    218              GPIO_ResetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4100      MOV      R1,#+32768
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_ResetBits
    219              GPIO_SetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4180      MOV      R1,#+16384
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_SetBits
    220          
    221              delay_us(100000); // 0.1s
   \   0000004A   0x....             LDR.N    R0,??DataTable10_15  ;; 0x186a0
   \   0000004C   0x.... 0x....      BL       delay_us
    222              stop();
   \   00000050   0x.... 0x....      BL       stop
    223          }
   \   00000054   0xBD01             POP      {R0,PC}          ;; return
    224          

   \                                 In section .text, align 2, keep-with-next
    225          void turn_left(void)
    226          {
   \                     turn_left: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    227              // Front Left: go backward
    228              GPIO_ResetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_ResetBits
    229              GPIO_SetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_SetBits
    230          
    231              // Front Right: go forward
    232              GPIO_SetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_SetBits
    233              GPIO_ResetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_ResetBits
    234          
    235              // Back Left: Stop
    236              GPIO_ResetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7100      MOV      R1,#+512
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_ResetBits
    237              GPIO_ResetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7180      MOV      R1,#+256
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    238          
    239              // Back Right: go forward
    240              GPIO_SetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4100      MOV      R1,#+32768
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_SetBits
    241              GPIO_ResetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4180      MOV      R1,#+16384
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    242          
    243              delay_us(500000); // 0.5s
   \   0000004A   0x....             LDR.N    R0,??DataTable10_16  ;; 0x7a120
   \   0000004C   0x.... 0x....      BL       delay_us
    244              stop();
   \   00000050   0x.... 0x....      BL       stop
    245          }
   \   00000054   0xBD01             POP      {R0,PC}          ;; return
    246          

   \                                 In section .text, align 2, keep-with-next
    247          void turn_right(void)
    248          {
   \                     turn_right: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    249              // Front Left: go forward
    250              GPIO_SetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_SetBits
    251              GPIO_ResetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_ResetBits
    252          
    253              // Front Right: go backward
    254              GPIO_ResetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_ResetBits
    255              GPIO_SetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_SetBits
    256          
    257              // Back Left: go forward
    258              GPIO_SetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7100      MOV      R1,#+512
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_SetBits
    259              GPIO_ResetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7180      MOV      R1,#+256
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    260          
    261              // Back Right: Stop
    262              GPIO_ResetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4100      MOV      R1,#+32768
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_ResetBits
    263              GPIO_ResetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4180      MOV      R1,#+16384
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    264          
    265              delay_us(500000); // 0.5s
   \   0000004A   0x....             LDR.N    R0,??DataTable10_16  ;; 0x7a120
   \   0000004C   0x.... 0x....      BL       delay_us
    266              stop();
   \   00000050   0x.... 0x....      BL       stop
    267          }
   \   00000054   0xBD01             POP      {R0,PC}          ;; return
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void stop(void)
    270          {
   \                     stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    271              GPIO_ResetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_ResetBits
    272              GPIO_ResetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_ResetBits
    273          
    274              GPIO_ResetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_ResetBits
    275              GPIO_SetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_SetBits
    276          
    277              GPIO_ResetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7100      MOV      R1,#+512
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_ResetBits
    278              GPIO_ResetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7180      MOV      R1,#+256
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    279          
    280              GPIO_ResetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4100      MOV      R1,#+32768
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_ResetBits
    281              GPIO_ResetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4180      MOV      R1,#+16384
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    282          }
   \   0000004A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x25 0x64          DC8      "%d\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     motor_mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     auto_counter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     flag_front_obstacle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     flag_left_obstacle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     flag_right_obstacle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x0007A120         DC32     0x7a120

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x64          DC8 "%d\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x67 0x6F          DC8 "go forward\012"
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x77 0x61    
   \              0x72 0x64    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x67 0x6F          DC8 "go backward\012"
   \              0x20 0x62    
   \              0x61 0x63    
   \              0x6B 0x77    
   \              0x61 0x72    
   \              0x64 0x0A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x74 0x75          DC8 "turn left\012"
   \              0x72 0x6E    
   \              0x20 0x6C    
   \              0x65 0x66    
   \              0x74 0x0A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x74 0x75          DC8 "turn right\012"
   \              0x72 0x6E    
   \              0x20 0x72    
   \              0x69 0x67    
   \              0x68 0x74    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x73 0x74          DC8 "stop\012"
   \              0x6F 0x70    
   \              0x0A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x41 0x75          DC8 "Auto mode activated\012"
   \              0x74 0x6F    
   \              0x20 0x6D    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x61 0x63    
   \              0x74 0x69    
   \              0x76 0x61    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x4D 0x61          DC8 "Manual mode activated\012"
   \              0x6E 0x75    
   \              0x61 0x6C    
   \              0x20 0x6D    
   \              0x6F 0x64    
   \              0x65 0x20    
   \              0x61 0x63    
   \              0x74 0x69    
   \              0x76 0x61    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   auto_control
         8   -> USART_SendData
         8   -> bt_get_user_input
         8   -> bt_send_to_user
         8   -> delay_us
         8   -> go_backward
         8   -> go_forward
         8   -> printf
         8   -> turn_left
         8   -> turn_right
       8   go_backward
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> delay_us
         8   -> stop
       8   go_forward
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> delay_us
         8   -> stop
       8   manual_control
         8   -> bt_get_user_input
         8   -> bt_send_to_user
         8   -> go_backward
         8   -> go_forward
         8   -> printf
         8   -> stop
         8   -> turn_left
         8   -> turn_right
       8   motor_control
         8   -> auto_control
         8   -> manual_control
       8   motor_gpio_configure
         8   -> GPIO_Init
       8   motor_init
         8   -> motor_gpio_configure
         8   -> motor_rcc_configure
         8   -> stop
       8   motor_rcc_configure
         8   -> RCC_APB2PeriphClockCmd
       8   stop
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   turn_left
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> delay_us
         8   -> stop
       8   turn_right
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> delay_us
         8   -> stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable8
       4  ?_0
      12  ?_1
      16  ?_2
      12  ?_3
      12  ?_4
       8  ?_5
      24  ?_6
      24  ?_7
     188  auto_control
       4  auto_counter
      86  go_backward
      86  go_forward
     128  manual_control
      30  motor_control
       4  motor_delay
     236  motor_gpio_configure
      24  motor_init
       4  motor_mode
      68  motor_rcc_configure
      76  stop
      86  turn_left
      86  turn_right

 
     8 bytes in section .bss
     4 bytes in section .data
   112 bytes in section .rodata
 1 166 bytes in section .text
 
 1 166 bytes of CODE  memory
   112 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: 2
