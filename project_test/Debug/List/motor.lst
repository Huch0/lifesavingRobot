###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       12/Dec/2024  15:40:40
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\motor.c
#    Command line =  
#        -f C:\Users\pnu2\AppData\Local\Temp\EWECCC.tmp
#        (C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\motor.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Debug\List
#        -o
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\
#        -I
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\inc\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Debug\List\motor.lst
#    Object file  =  
#        C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\Debug\Obj\motor.o
#
###############################################################################

C:\Users\pnu2\Documents\GitHub\lifesavingRobot\project_test\user\motor.c
      1          #include "motor.h"
      2          
      3          extern int flag_front_obstacle;
      4          extern int flag_left_obstacle;
      5          extern int flag_right_obstacle;
      6          extern int flag_back_obstacle;
      7          

   \                                 In section .bss, align 4
      8          int motor_mode;
   \                     motor_mode:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
      9          unsigned int motor_delay = 1000000;
   \                     motor_delay:
   \   00000000   0x000F4240         DC32 1000000
     10          
     11          

   \                                 In section .text, align 2, keep-with-next
     12          void motor_rcc_configure(void)
     13          {
   \                     motor_rcc_configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     14              RCC_APB2PeriphClockCmd(MOTOR_FL1_RCC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     15              RCC_APB2PeriphClockCmd(MOTOR_FL2_RCC, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     16              RCC_APB2PeriphClockCmd(MOTOR_FR1_RCC, ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     17              RCC_APB2PeriphClockCmd(MOTOR_FR2_RCC, ENABLE);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     18              RCC_APB2PeriphClockCmd(MOTOR_BL1_RCC, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     19              RCC_APB2PeriphClockCmd(MOTOR_BL2_RCC, ENABLE);
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x2020             MOVS     R0,#+32
   \   0000002E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     20              RCC_APB2PeriphClockCmd(MOTOR_BR1_RCC, ENABLE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     21              RCC_APB2PeriphClockCmd(MOTOR_BR2_RCC, ENABLE);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x2020             MOVS     R0,#+32
   \   0000003E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     22          }
   \   00000042   0xBD01             POP      {R0,PC}          ;; return
     23          

   \                                 In section .text, align 2, keep-with-next
     24          void motor_gpio_configure(void)
     25          {
   \                     motor_gpio_configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     26              GPIO_InitTypeDef GPIO_InitStructure;
     27              GPIO_InitStructure.GPIO_Pin = MOTOR_FL1_PIN;
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     28              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     29              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0xF88D 0x0003      STRB     R0,[SP, #+3]
     30              GPIO_Init(MOTOR_FL1_PORT, &GPIO_InitStructure);
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x40011400
   \   0000001A   0x.... 0x....      BL       GPIO_Init
     31          
     32              GPIO_InitStructure.GPIO_Pin = MOTOR_FL2_PIN;
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     33              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xF88D 0x0002      STRB     R0,[SP, #+2]
     34              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000002A   0x2010             MOVS     R0,#+16
   \   0000002C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     35              GPIO_Init(MOTOR_FL2_PORT, &GPIO_InitStructure);
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000034   0x.... 0x....      BL       GPIO_Init
     36          
     37              GPIO_InitStructure.GPIO_Pin = MOTOR_FR1_PIN;
   \   00000038   0x2010             MOVS     R0,#+16
   \   0000003A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     38              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0xF88D 0x0002      STRB     R0,[SP, #+2]
     39              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000044   0x2010             MOVS     R0,#+16
   \   00000046   0xF88D 0x0003      STRB     R0,[SP, #+3]
     40              GPIO_Init(MOTOR_FR1_PORT, &GPIO_InitStructure);
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000004E   0x.... 0x....      BL       GPIO_Init
     41          
     42              GPIO_InitStructure.GPIO_Pin = MOTOR_FR2_PIN;
   \   00000052   0x2080             MOVS     R0,#+128
   \   00000054   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     43              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     44              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000005E   0x2010             MOVS     R0,#+16
   \   00000060   0xF88D 0x0003      STRB     R0,[SP, #+3]
     45              GPIO_Init(MOTOR_FR2_PORT, &GPIO_InitStructure);
   \   00000064   0x4669             MOV      R1,SP
   \   00000066   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000068   0x.... 0x....      BL       GPIO_Init
     46          
     47              GPIO_InitStructure.GPIO_Pin = MOTOR_BL1_PIN;
   \   0000006C   0xF44F 0x7080      MOV      R0,#+256
   \   00000070   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     48              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0xF88D 0x0002      STRB     R0,[SP, #+2]
     49              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000007A   0x2010             MOVS     R0,#+16
   \   0000007C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     50              GPIO_Init(MOTOR_BL1_PORT, &GPIO_InitStructure);
   \   00000080   0x4669             MOV      R1,SP
   \   00000082   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000084   0x.... 0x....      BL       GPIO_Init
     51          
     52              GPIO_InitStructure.GPIO_Pin = MOTOR_BL2_PIN;
   \   00000088   0xF44F 0x7000      MOV      R0,#+512
   \   0000008C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     53              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xF88D 0x0002      STRB     R0,[SP, #+2]
     54              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000096   0x2010             MOVS     R0,#+16
   \   00000098   0xF88D 0x0003      STRB     R0,[SP, #+3]
     55              GPIO_Init(MOTOR_BL2_PORT, &GPIO_InitStructure);
   \   0000009C   0x4669             MOV      R1,SP
   \   0000009E   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   000000A0   0x.... 0x....      BL       GPIO_Init
     56          
     57              GPIO_InitStructure.GPIO_Pin = MOTOR_BR1_PIN;
   \   000000A4   0xF44F 0x4080      MOV      R0,#+16384
   \   000000A8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     58              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000AC   0x2003             MOVS     R0,#+3
   \   000000AE   0xF88D 0x0002      STRB     R0,[SP, #+2]
     59              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   000000B2   0x2010             MOVS     R0,#+16
   \   000000B4   0xF88D 0x0003      STRB     R0,[SP, #+3]
     60              GPIO_Init(MOTOR_BR1_PORT, &GPIO_InitStructure);
   \   000000B8   0x4669             MOV      R1,SP
   \   000000BA   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   000000BC   0x.... 0x....      BL       GPIO_Init
     61          
     62              GPIO_InitStructure.GPIO_Pin = MOTOR_BR2_PIN;
   \   000000C0   0xF44F 0x4000      MOV      R0,#+32768
   \   000000C4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     63              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000C8   0x2003             MOVS     R0,#+3
   \   000000CA   0xF88D 0x0002      STRB     R0,[SP, #+2]
     64              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   000000CE   0x2010             MOVS     R0,#+16
   \   000000D0   0xF88D 0x0003      STRB     R0,[SP, #+3]
     65              GPIO_Init(MOTOR_BR2_PORT, &GPIO_InitStructure);
   \   000000D4   0x4669             MOV      R1,SP
   \   000000D6   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   000000D8   0x.... 0x....      BL       GPIO_Init
     66          }
   \   000000DC   0xBD01             POP      {R0,PC}          ;; return
     67          

   \                                 In section .text, align 2, keep-with-next
     68          void motor_init(void)
     69          {
   \                     motor_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     70              motor_rcc_configure();
   \   00000002   0x.... 0x....      BL       motor_rcc_configure
     71              motor_gpio_configure();
   \   00000006   0x.... 0x....      BL       motor_gpio_configure
     72              motor_mode = MOTOR_AUTO;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x....             LDR.N    R1,??DataTable10_1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     73          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
     74          
     75          
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void manual_control(void)
     78          {
   \                     manual_control: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     79              char user_input = bt_get_user_input();
                                       ^
Warning[Pe223]: function "bt_get_user_input" declared implicitly
   \   00000002   0x.... 0x....      BL       bt_get_user_input
     80              switch (user_input)
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x2861             CMP      R0,#+97
   \   0000000A   0xD010             BEQ.N    ??manual_control_0
   \   0000000C   0x2863             CMP      R0,#+99
   \   0000000E   0xD017             BEQ.N    ??manual_control_1
   \   00000010   0x2864             CMP      R0,#+100
   \   00000012   0xD00F             BEQ.N    ??manual_control_2
   \   00000014   0x2873             CMP      R0,#+115
   \   00000016   0xD007             BEQ.N    ??manual_control_3
   \   00000018   0x2877             CMP      R0,#+119
   \   0000001A   0xD002             BEQ.N    ??manual_control_4
   \   0000001C   0x2878             CMP      R0,#+120
   \   0000001E   0xD00C             BEQ.N    ??manual_control_5
   \   00000020   0xE012             B.N      ??manual_control_6
     81              {
     82              case 'w':
     83                  go_forward();
   \                     ??manual_control_4: (+1)
   \   00000022   0x.... 0x....      BL       go_forward
     84                  break;
   \   00000026   0xE00F             B.N      ??manual_control_7
     85              case 's':
     86                  go_backward();
   \                     ??manual_control_3: (+1)
   \   00000028   0x.... 0x....      BL       go_backward
     87                  break;
   \   0000002C   0xE00C             B.N      ??manual_control_7
     88              case 'a':
     89                  turn_left();
   \                     ??manual_control_0: (+1)
   \   0000002E   0x.... 0x....      BL       turn_left
     90                  break;
   \   00000032   0xE009             B.N      ??manual_control_7
     91              case 'd':
     92                  turn_right();
   \                     ??manual_control_2: (+1)
   \   00000034   0x.... 0x....      BL       turn_right
     93                  break;
   \   00000038   0xE006             B.N      ??manual_control_7
     94              case 'x':
     95                  stop();
   \                     ??manual_control_5: (+1)
   \   0000003A   0x.... 0x....      BL       stop
     96                  break;
   \   0000003E   0xE003             B.N      ??manual_control_7
     97              case 'c':
     98                  motor_mode = MOTOR_AUTO;
   \                     ??manual_control_1: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             LDR.N    R1,??DataTable10_1
   \   00000044   0x6008             STR      R0,[R1, #+0]
     99                  break;
   \   00000046   0xE7FF             B.N      ??manual_control_7
    100              default:
    101                  break;
    102              }
    103          }
   \                     ??manual_control_6: (+1)
   \                     ??manual_control_7: (+1)
   \   00000048   0xBD01             POP      {R0,PC}          ;; return
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void auto_control()
    106          {
   \                     auto_control: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    107              if (!flag_front_obstacle)
   \   00000002   0x....             LDR.N    R0,??DataTable10_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD102             BNE.N    ??auto_control_0
    108              {
    109                  go_forward();
   \   0000000A   0x.... 0x....      BL       go_forward
   \   0000000E   0xE016             B.N      ??auto_control_1
    110              }
    111              else if (!flag_left_obstacle)
   \                     ??auto_control_0: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable10_3
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD102             BNE.N    ??auto_control_2
    112              {
    113                  turn_left();
   \   00000018   0x.... 0x....      BL       turn_left
   \   0000001C   0xE00F             B.N      ??auto_control_1
    114              }
    115              else if (!flag_right_obstacle)
   \                     ??auto_control_2: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable10_4
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD102             BNE.N    ??auto_control_3
    116              {
    117                  turn_right();
   \   00000026   0x.... 0x....      BL       turn_right
   \   0000002A   0xE008             B.N      ??auto_control_1
    118              }
    119              else if (!flag_back_obstacle)
   \                     ??auto_control_3: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable10_5
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD102             BNE.N    ??auto_control_4
    120              {
    121                  go_backward();
   \   00000034   0x.... 0x....      BL       go_backward
   \   00000038   0xE001             B.N      ??auto_control_1
    122              }
    123              else
    124              {
    125                  stop();
   \                     ??auto_control_4: (+1)
   \   0000003A   0x.... 0x....      BL       stop
    126              }
    127          }
   \                     ??auto_control_1: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    128          

   \                                 In section .text, align 2, keep-with-next
    129          void motor_control()
    130          {
   \                     motor_control: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    131              if (motor_mode == MOTOR_MANUAL)
   \   00000002   0x....             LDR.N    R0,??DataTable10_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD102             BNE.N    ??motor_control_0
    132              {
    133                  manual_control();
   \   0000000A   0x.... 0x....      BL       manual_control
   \   0000000E   0xE005             B.N      ??motor_control_1
    134              }
    135              else if (motor_mode == MOTOR_AUTO)
   \                     ??motor_control_0: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable10_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD101             BNE.N    ??motor_control_1
    136              {
    137                  auto_control();
   \   00000018   0x.... 0x....      BL       auto_control
    138              }
    139          }
   \                     ??motor_control_1: (+1)
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    140          

   \                                 In section .text, align 2, keep-with-next
    141          void go_forward(void)
    142          {
   \                     go_forward: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    143              GPIO_SetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_SetBits
    144              GPIO_ResetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_ResetBits
    145          
    146              GPIO_SetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_SetBits
    147              GPIO_ResetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_ResetBits
    148          
    149              GPIO_SetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7180      MOV      R1,#+256
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_SetBits
    150              GPIO_ResetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7100      MOV      R1,#+512
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    151          
    152              GPIO_SetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4180      MOV      R1,#+16384
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_SetBits
    153              GPIO_ResetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4100      MOV      R1,#+32768
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    154          
    155              delay(motor_delay);
   \   0000004A   0x....             LDR.N    R0,??DataTable10_6
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       delay
    156              stop();
   \   00000052   0x.... 0x....      BL       stop
    157          }
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    158          

   \                                 In section .text, align 2, keep-with-next
    159          void go_backward(void)
    160          {
   \                     go_backward: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    161              GPIO_ResetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_ResetBits
    162              GPIO_SetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_SetBits
    163          
    164              GPIO_ResetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_ResetBits
    165              GPIO_SetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_SetBits
    166          
    167              GPIO_ResetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7180      MOV      R1,#+256
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_ResetBits
    168              GPIO_SetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7100      MOV      R1,#+512
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_SetBits
    169          
    170              GPIO_ResetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4180      MOV      R1,#+16384
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_ResetBits
    171              GPIO_SetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4100      MOV      R1,#+32768
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_SetBits
    172          
    173              delay(motor_delay);
   \   0000004A   0x....             LDR.N    R0,??DataTable10_6
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       delay
    174              stop();
   \   00000052   0x.... 0x....      BL       stop
    175          }
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    176          

   \                                 In section .text, align 2, keep-with-next
    177          void turn_left(void)
    178          {
   \                     turn_left: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    179              // Front Left: go backward
    180              GPIO_ResetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_ResetBits
    181              GPIO_SetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_SetBits
    182          
    183              // Front Right: go forward
    184              GPIO_SetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_SetBits
    185              GPIO_ResetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_ResetBits
    186          
    187              // Back Left: Stop
    188              GPIO_ResetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7180      MOV      R1,#+256
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_ResetBits
    189              GPIO_ResetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7100      MOV      R1,#+512
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    190          
    191              // Back Right: go forward
    192              GPIO_SetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4180      MOV      R1,#+16384
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_SetBits
    193              GPIO_ResetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4100      MOV      R1,#+32768
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    194          
    195              delay(motor_delay);
   \   0000004A   0x....             LDR.N    R0,??DataTable10_6
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       delay
    196              stop();
   \   00000052   0x.... 0x....      BL       stop
    197          }
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    198          

   \                                 In section .text, align 2, keep-with-next
    199          void turn_right(void)
    200          {
   \                     turn_right: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    201              // Front Left: go forward
    202              GPIO_SetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_SetBits
    203              GPIO_ResetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_ResetBits
    204          
    205              // Front Right: go backward
    206              GPIO_ResetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_ResetBits
    207              GPIO_SetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_SetBits
    208          
    209              // Back Left: go forward
    210              GPIO_SetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7180      MOV      R1,#+256
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_SetBits
    211              GPIO_ResetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7100      MOV      R1,#+512
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    212          
    213              // Back Right: Stop
    214              GPIO_ResetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4180      MOV      R1,#+16384
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_ResetBits
    215              GPIO_ResetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4100      MOV      R1,#+32768
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    216          
    217              delay(motor_delay);
   \   0000004A   0x....             LDR.N    R0,??DataTable10_6
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       delay
    218              stop();
   \   00000052   0x.... 0x....      BL       stop
    219          }
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
    220          

   \                                 In section .text, align 2, keep-with-next
    221          void stop(void)
    222          {
   \                     stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    223              GPIO_ResetBits(MOTOR_FL1_PORT, MOTOR_FL1_PIN);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000006   0x.... 0x....      BL       GPIO_ResetBits
    224              GPIO_ResetBits(MOTOR_FL2_PORT, MOTOR_FL2_PIN);
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000000E   0x.... 0x....      BL       GPIO_ResetBits
    225          
    226              GPIO_ResetBits(MOTOR_FR1_PORT, MOTOR_FR1_PIN);
   \   00000012   0x2110             MOVS     R1,#+16
   \   00000014   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000016   0x.... 0x....      BL       GPIO_ResetBits
    227              GPIO_ResetBits(MOTOR_FR2_PORT, MOTOR_FR2_PIN);
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000001E   0x.... 0x....      BL       GPIO_ResetBits
    228          
    229              GPIO_ResetBits(MOTOR_BL1_PORT, MOTOR_BL1_PIN);
   \   00000022   0xF44F 0x7180      MOV      R1,#+256
   \   00000026   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000028   0x.... 0x....      BL       GPIO_ResetBits
    230              GPIO_ResetBits(MOTOR_BL2_PORT, MOTOR_BL2_PIN);
   \   0000002C   0xF44F 0x7100      MOV      R1,#+512
   \   00000030   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000032   0x.... 0x....      BL       GPIO_ResetBits
    231          
    232              GPIO_ResetBits(MOTOR_BR1_PORT, MOTOR_BR1_PIN);
   \   00000036   0xF44F 0x4180      MOV      R1,#+16384
   \   0000003A   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   0000003C   0x.... 0x....      BL       GPIO_ResetBits
    233              GPIO_ResetBits(MOTOR_BR2_PORT, MOTOR_BR2_PIN);
   \   00000040   0xF44F 0x4100      MOV      R1,#+32768
   \   00000044   0x....             LDR.N    R0,??DataTable10  ;; 0x40011400
   \   00000046   0x.... 0x....      BL       GPIO_ResetBits
    234          }
   \   0000004A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     motor_mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     flag_front_obstacle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     flag_left_obstacle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     flag_right_obstacle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     flag_back_obstacle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     motor_delay

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   auto_control
         8   -> go_backward
         8   -> go_forward
         8   -> stop
         8   -> turn_left
         8   -> turn_right
       8   go_backward
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> delay
         8   -> stop
       8   go_forward
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> delay
         8   -> stop
       8   manual_control
         8   -> bt_get_user_input
         8   -> go_backward
         8   -> go_forward
         8   -> stop
         8   -> turn_left
         8   -> turn_right
       8   motor_control
         8   -> auto_control
         8   -> manual_control
       8   motor_gpio_configure
         8   -> GPIO_Init
       8   motor_init
         8   -> motor_gpio_configure
         8   -> motor_rcc_configure
       8   motor_rcc_configure
         8   -> RCC_APB2PeriphClockCmd
       8   stop
         8   -> GPIO_ResetBits
       8   turn_left
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> delay
         8   -> stop
       8   turn_right
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
         8   -> delay
         8   -> stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
      64  auto_control
      88  go_backward
      88  go_forward
      74  manual_control
      30  motor_control
       4  motor_delay
     222  motor_gpio_configure
      18  motor_init
       4  motor_mode
      68  motor_rcc_configure
      76  stop
      88  turn_left
      88  turn_right

 
   4 bytes in section .bss
   4 bytes in section .data
 932 bytes in section .text
 
 932 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: 1
